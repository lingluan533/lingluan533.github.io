<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>凌乱\</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="凌乱\">
<meta property="og:url" content="http://lingluan533.github.io/lingluan533.github.io/page/2/index.html">
<meta property="og:site_name" content="凌乱\">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Maosheng Zhang">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/nexmoe/nexmoe.github.io@latest/css/style.css,npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css" crossorigin>
  
  <!--<link rel="stylesheet" href="/lingluan533.github.io/css/style.css?v=1585654070932">-->

  
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/lingluan533.github.io/" title="Maosheng Zhang" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="Maosheng Zhang"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/lingluan533.github.io/" title="Maosheng Zhang">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="Maosheng Zhang" alt="Maosheng Zhang">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>25</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/lingluan533.github.io/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/lingluan533.github.io/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/lingluan533.github.io/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lingluan533.github.io/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lingluan533.github.io/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lingluan533.github.io/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lingluan533.github.io/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lingluan533.github.io/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2020 Maosheng Zhang
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2018/02/13/UVA129%20Krypton%20Factor%20%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2%20dfs%E5%9B%9E%E6%BA%AF%E3%80%90DFS%E3%80%91/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="UVA129 Krypton Factor 困难的串 dfs回溯【DFS】" class="lazyload">
                    <h1>UVA129 Krypton Factor 困难的串 dfs回溯【DFS】</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年02月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <p>﻿﻿</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1627" target="_blank" rel="noopener"> Krypton Factor  
</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1627" target="_blank" rel="noopener"> </a> ** <strong>Time Limit: 2000/1000<br>MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)</strong> **</p>
<p>** <strong>Total Submission(s): 392 Accepted Submission(s): 174</strong> **  </p>
<p>Problem Description</p>
<p>You have been employed by the organisers of a Super Krypton Factor Contest in<br>which contestants have very high mental and physical abilities. In one section<br>of the contest the contestants are tested on their ability to recall a<br>sequenace of characters which has been read to them by the Quiz Master. Many<br>of the contestants are very good at recognising patterns. Therefore, in order<br>to add some difficulty to this test, the organisers have decided that<br>sequences containing certain types of repeated subsequences should not be<br>used. However, they do not wish to remove all subsequences that are repeated,<br>since in that case no single character could be repeated. This in itself would<br>make the problem too easy for the contestants. Instead it is decided to<br>eliminate all sequences containing an occurrence of two adjoining identical<br>subsequences. Sequences containing such an occurrence will be called <code>easy&#39;&#39;.
Other sequences will be called</code>hard’’.  </p>
<p>For example, the sequence ABACBCBAD is easy, since it contains an adjoining<br>repetition of the subsequence CB. Other examples of easy sequences are:  </p>
<p>BB<br>ABCDACABCAB<br>ABCDABCD  </p>
<p>Some examples of hard sequences are:  </p>
<p>D<br>DC<br>ABDAB<br>CBABCBA  </p>
<p>Input</p>
<p>In order to provide the Quiz Master with a potentially unlimited source of<br>questions you are asked to write a program that will read input lines that<br>contain integers n and L (in that order), where n &gt; 0 and L is in the range ,<br>and for each input line prints out the nth hard sequence (composed of letters<br>drawn from the first L letters in the alphabet), in increasing alphabetical<br>order (alphabetical ordering here corresponds to the normal ordering<br>encountered in a dictionary), followed (on the next line) by the length of<br>that sequence. The first sequence in this ordering is A. You may assume that<br>for given n and L there do exist at least n hard sequences.  </p>
<p>For example, with L = 3, the first 7 hard sequences are:  </p>
<p>A<br>AB<br>ABA<br>ABAC<br>ABACA<br>ABACAB<br>ABACABA<br>As each sequence is potentially very long, split it into groups of four (4)<br>characters separated by a space. If there are more than 16 such groups, please<br>start a new line for the 17th group.  </p>
<p>Therefore, if the integers 7 and 3 appear on an input line, the output lines<br>produced should be  </p>
<p>ABAC ABA<br>7<br>Input is terminated by a line containing two zeroes. Your program may assume a<br>maximum sequence length of 80.  </p>
<p>Sample Input</p>
<p>30 30 0</p>
<p>Sample Output</p>
<p>ABAC ABCA CBAB CABA CABC ACBA CABA28</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=uva&source=1&searchmode=source" target="_blank" rel="noopener"> uva
</a></p>
<h1 id="问题简介："><a href="#问题简介：" class="headerlink" title="问题简介："></a>问题简介：</h1><p>输入正整数n和L，输出由前L个字符组成的、字典顺序第n小的不含相邻重复字串的字符串。  不含相邻重复字串的字符串<br>是指，一个字符串中，任意两个相邻的字串都不相等。输出结果时，对于找到的字符串，每４个字符间加入一个空格，每行输出８０个字符。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h2><p>##<br>大致的框架就是每次增加一个字符，在增加字符的同时去判断加上这个字符后是否产生了连续的相同子串，这也是很关键的一个点，如何判断是否产生了连续的相同子串，由于采用了回溯的思想，故以前的串是没有连续的相同子串的，故只需从后向前看包含了新字母后有无连续的相同子串。我们可以外层循环去遍历两个子串的长度，从1-(cur+1)/2(即当前串的一半)，内层循环去遍历每一对子串的对应的点，如果在内层循环找到了一个点在两个子串上的对应位置不相等，则在此长度下没有产生连续的相同子串。于是，外层循环的长度加1，去判断下一个子串是否相同。如果找到了某一对连续的相同子串，则此次的分配不合理，尝试在该点分配下一个小于L的字母，如果没有找到一对连续的相同子串，则此次分配合理，可以递归下一个点，并且记录困难子串的变量加一。当变量等于n的时候则输出该序列即可。<br>由于无需返回值，所以直接return 即可。</p>
<pre><code>package lianxi;

import java.util.Scanner;

public class KryptonFactorUva129 {
    static Scanner scan = new Scanner(System.in);
    static int C[]=new int [10000];
    static int n,l,count=0;
    public static void main(String[] args) {
        while(scan.hasNext()){
            n = scan.nextInt();
            l = scan.nextInt();
            getFactor(0);
            for(int i=0;i&lt;C.length;i++){
                C[i] = 0;
            }
        }
    }
    private static int getFactor(int cur) {

        if(count++ == n){
            for(int i = 0;i&lt;cur;i++){
                System.out.print((char)(C[i]+&apos;A&apos;));
            }
            System.out.println();

            return 0;
        }

        for(int i=0;i&lt;l;i++){
            C[cur] = i;
            int ok = 1;
            for(int j = 1;j*2&lt;=cur+1;j++){
                int equal = 1;
                for(int k = 0;k &lt; j;k++){
                    if(C[cur - k] != C[cur-k-j] ){
                        equal = 0;   //找到一个不相同的点本次的测试子段即为困难的串
                        break;
                    }
                }
                if(equal == 1){
                    ok = 0;
                    break;    //存在了相同的连续子串，尝试下一个字母
                }
            }
            if(ok==1){
                if(getFactor(cur+1) == 0){
                    return 0;
                }
            }

        }
        return 1;


    }

}</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2018/02/13/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%20%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97%20%20%20%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E3%80%91/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="算法训练 求先序排列   【二叉树的递归遍历】" class="lazyload">
                    <h1>算法训练 求先序排列   【二叉树的递归遍历】</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年02月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>315 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>算法训练 求先序排列</p>
<p>时间限制：1.0s 内存限制：256.0MB</p>
<p>锦囊1</p>
<p>锦囊2</p>
<p>锦囊3</p>
<p><strong>问题描述</strong><br>给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度&lt;=8）。</p>
<p>输入格式</p>
<p>两行，每行一个字符串，分别表示中序和后序排列</p>
<p>输出格式</p>
<p>一个字符串，表示所求先序排列  </p>
<p><strong>样例</strong> 输入<br>BADC<br>BDCA</p>
<p>样例输出</p>
<p>ABCD</p>
<p>递归的突破点在于<br>：后序的最后一个节点为每个子树的根节点，而中序中又可以根据这个根节点将树划分为左右子树，形成了问题的分解，这样就可以每一次递归的访问子树并输出其根节点了！</p>
<pre><code>package demo;

import java.util.Scanner;

public class Main先序排列{
    static Scanner scan = new Scanner(System.in);
    static String a,b;
    public static void main(String[] args) {
        a = scan.nextLine();
        b = scan.nextLine();
        tree(a,b);
        System.out.println();
    }
    private static void tree(String a2, String b2) {
        char tar = b2.charAt(b2.length()-1);
        int index =a2.indexOf(tar);
        System.out.print(tar);
        if(index &gt; 0){
            tree(a2.substring(0,a2.indexOf(b2.charAt(b2.length()-1))),b2.substring(0, a2.indexOf(b2.charAt(b2.length()-1))));
        }
        if(index &lt; a2.length()-1){
            tree(a2.substring(index+1),b2.substring(index,b2.length()-1));
        }

    }





}</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2018/02/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%20%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%20java%E7%89%88%20%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="算法学习 八皇后问题的递归实现 java版 回溯思想" class="lazyload">
                    <h1>算法学习 八皇后问题的递归实现 java版 回溯思想</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年02月12日</a>
            <a><i class="nexmoefont icon-areachart"></i>713 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
        </div>

        <article>
            
                <p>** 1.问题描述  **</p>
<p>八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8<br>的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当<br>n = 1 或 n ≥ 4 时问题有解。</p>
<p>![](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdn.net/20180212210140811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk2ODM1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  </p>
<p>** 2.思路分析  **</p>
<hr>
<p>回溯法：  当把问题分成若干步骤并递归求解时，如果当前步骤没有合法的选择时，则函数即调用上一层的递归，此即为回溯。</p>
<p>在每次的正向递归时是一个试探的过程，将本次的影响带入到下一次的递归过程中去，如果在下一次的函数中，并没有找到一个合适的解去调用在下一层的函数，则证明上一次的函数过程产生了不正确的中间结果，这个结果使得整个函数不能被正确执行了，所以此时应返回对于全局变量的影响（如果产生了如果有必要，回溯法的过程中大多数是有必要返回这个影响的），然后再次去试探。。。一直到达递归的出口。</p>
<p>八皇后问题的思路即：</p>
<p>1）：以行的方式去摆放棋子</p>
<p>2）：在每次的试探摆放时，检查是否有以前的棋子与本次拟摆放的位置相冲突，（由于是按行摆放，故只需验证是否有同一列和同一对角线即可）  </p>
<p>3）： 如果产生了冲突，则返回上一层的调用</p>
<p>4）：如果产生了符合条件的位置，则进入下一行的判断</p>
<pre><code>package lianxi;

import java.util.Scanner;

public class EightQueen {
        static int tol = 0,n;
        static int C[] ;
        static Scanner scan = new Scanner(System.in);
    public static void main(String[] args) {
             n = scan.nextInt();
            C = new int[n];
            for(int j=0;j&lt;n;j++){
                C[j] = 0;
            }

         search(0);
        System.out.println(tol);

    }
    private static void search(int cur) {
            if(cur == n){
                tol++;
                System.out.println(&quot;第&quot;+tol+&quot;种放法：&quot;);
            for(int i = 0;i&lt; n;i++){
                for(int i1 = 0;i1&lt; n;i1++){
                    if(C[i] == i1)
                        System.out.print(&apos;Q&apos;);
                    else
                        System.out.print(&apos;+&apos;);
                }
                System.out.println();
            }
            System.out.println();
            }else {
                for(int j = 0;j&lt;n;j++){
                    int ok = 1;
                    C[cur] = j;
                    for(int k = 0;k&lt;cur ;k++){
                        if(C[k] == C[cur] || C[k] - k ==C[cur]-cur || C[cur] + cur == C[k] + k ){


//C[k] - k ==C[cur]-cur   C[cur] + cur == C[k] + k分别用于判断是否有与当前位置处于右下对角线和左下对角线的皇后
                        ok = 0;
                        break;
                        }
                    }
                    if(ok==1)search(cur+1);
                }

            }


    }


}</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2018/02/08/UVa%2011059%20%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%20java%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="UVa 11059 最大乘积 java 暴力破解" class="lazyload">
                    <h1>UVa 11059 最大乘积 java 暴力破解</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年02月08日</a>
            <a><i class="nexmoefont icon-areachart"></i>173 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>题目链接：</p>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2000" target="_blank" rel="noopener">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2000</a>  </p>
<p>暴力破解</p>
<p>import java.util.Scanner;  </p>
<p>public class MaxProduct {<br>static Scanner scan = new Scanner(System.in);<br>public static void main(String[] args) {<br>int count ;<br>int data[];<br>long a ;<br>long max ;<br>while(scan.hasNext()){<br>max = 0;  </p>
<p>count = scan.nextInt();<br>data = new int[count];<br>for(int i=0;i&lt;count;i++){<br>data[i] = scan.nextInt();<br>}<br>for(int i=1;i&lt;=count;i++){ //先由不同长度枚举  </p>
<p>for(int j = 0;i+j&lt;=count;j++){ //相同的长度根据不同的起点划分<br>a = 1;<br>for(int x = j;x&lt;j+i;x++){ //对每个段内进行累乘，将该序列与纪录最大量的变量进行对比，赋值给最大量变量<br>a *= data[x];<br>}<br>max = Math.max(max, a);<br>}<br>}<br>System.out.println(max);<br>}<br>}  </p>
<p>}</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2018/02/06/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B0%83%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="java基本数据类型和引用数据类型的调用传递的区别" class="lazyload">
                    <h1>java基本数据类型和引用数据类型的调用传递的区别</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年02月06日</a>
            <a><i class="nexmoefont icon-areachart"></i>338 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>（1）基本数据类型：就是进行了值的传递把一份数据拷贝了之后传递过去</p>
<p>（2）引用数据类型：实际上也是进行了数据拷贝然后传过去，实际上也是值传递，只  不过传递过去的值和原有的值指向了同一个对象<br>所以在调用的方法中可以对原来的数据进行影响，这是因为二者指向的是同一个对象。 但这不是按引用调用！如下代码可证明这一点：</p>
<p>对象之间的赋值是需要指针相互赋值的，而由于这里User<br>x和y仅仅是一个值的拷贝，他们仅仅是表面上的东西是一个实例，对他们进行交换不会影响在底层的真正的对象的交换。所以这个函数调用不会引起两个对象的交换</p>
<p>但是如果在被调用的函数中  ，拷贝的对象执行了对于真正对象的数据修改是可以改变后续的对象的值的，因为后续的对象仍然会引用这个被修改过的对象<br>。比如以下代码证明了这一点：</p>
<p>这个过程实际上是这样的：</p>
<p>![](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdn.net/20160419170656251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2017/12/07/%E4%BD%BF%E7%94%A8sstream%E8%BF%9B%E8%A1%8Cint%E8%BD%AC%E6%8D%A2string%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="使用sstream进行int转换string的注意事项" class="lazyload">
                    <h1>使用sstream进行int转换string的注意事项</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年12月07日</a>
            <a><i class="nexmoefont icon-areachart"></i>353 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>个人网站 ：<a href="http://39.106.25.239/" target="_blank" rel="noopener">http://39.106.25.239/</a></p>
<p>1.引入sstream文件</p>
<p>2.使用stringstream 声明</p>
<p>3.使用一次sstream转换后要执行成员函数.clear() 来清除stringstream中的字符串 否则，永远只对第一次的字符串生效。</p>
<p>转载自： <a href="http://www.cnitblog.com/30701735/articles/44699.html" target="_blank" rel="noopener"> http://www.cnitblog.com/30701735/articles/44699.html
</a></p>
<p>C++标准库中的stringStreams是从iostream类派生而来的,也因为其内部重载了针对各重内置类型和某些标准库类型(如string)的确”&lt;&lt;”和”&gt;&gt;”操作符,所以可以用来进行类型之间的转换.看起来比较简单,但因为一般的C++书籍对其介绍比较少,经过测试之后发觉有些东西还是需要注意的.<br>例如以下代码段:  </p>
<p>1  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> int  a;<br>2  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> //  字符串流<br>3  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"><br>stringstream strStream;<br>4  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream<br>&lt;&lt; “345”;<br>5  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream</p>
<blockquote>
<blockquote>
<p>a;<br>6  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> cout &lt;&lt; a<br>&lt;&lt; endl;<br>7  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"><br>strStream.clear();<br>8  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream<br>&lt;&lt; “34561”;<br>9  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream<br>a;<br>10  <img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> cout &lt;&lt; a<br>&lt;&lt; endl;</p>
</blockquote>
</blockquote>
<p>输出为:<br><img data-sizes="auto" data-src="http://www.cnitblog.com/images/cnitblog_com/30701735/1.JPG" alt="" class="lazyload"><br>但如果稍微改动下代码:  </p>
<p><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream &lt;&lt;<br>“345a”;<br><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream &gt;&gt;<br>a;<br><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> cout &lt;&lt; a &lt;&lt;<br>endl;<br><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"><br>strStream.clear();<br><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream &lt;&lt;<br>“34561”;<br><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> strStream &gt;&gt;<br>a;<br><img data-sizes="auto" data-src="http://www.cnitblog.com/Images/OutliningIndicators/None.gif" alt="" class="lazyload"> cout &lt;&lt; a &lt;&lt;<br>endl;</p>
<p>则输出结果就变为:<br><img data-sizes="auto" data-src="http://www.cnitblog.com/images/cnitblog_com/30701735/2.JPG" alt="" class="lazyload"><br>为什么呢?因为 strStream &lt;&lt; “345a”;<br>strStream &gt;&gt;<br>a;这两句并未将strStream内的内容读取完毕导致strStream.clear()无效,程序并没有清除strStream中的字符串,所以在下次从strStream中输出的时候还是会读取到345.</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2017/12/06/pat%20%E4%B9%99%E7%BA%A7%201015.%20%E5%BE%B7%E6%89%8D%E8%AE%BA%20(25)%20c++/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="pat 乙级 1015. 德才论 (25) c++" class="lazyload">
                    <h1>pat 乙级 1015. 德才论 (25) c++</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年12月06日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 7 分钟</a>
        </div>

        <article>
            
                <p>﻿﻿</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><a href="http://39.106.25.239" target="_blank" rel="noopener"> http://39.106.25.239 </a></p>
<p>个人网站 欢迎访问 交流</p>
<h1 id="1015-德才论-25"><a href="#1015-德才论-25" class="headerlink" title="1015. 德才论 (25)"></a>1015. 德才论 (25)</h1><p>时间限制</p>
<p>200 ms  </p>
<p>内存限制</p>
<p>65536 kB  </p>
<p>代码长度限制</p>
<p>8000 B  </p>
<p>判题程序</p>
<p>Standard</p>
<p>作者</p>
<p>CHEN, Li  </p>
<p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p>
<p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>
<p><strong>输入格式：</strong></p>
<p>输入第1行给出3个正整数，分别为：N（&lt;=10  5<br>），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。</p>
<p>随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。</p>
<p><strong>输出格式：</strong></p>
<p>输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>
<p><strong>输入样例：</strong></p>
<pre><code>14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60</code></pre><p><strong>输出样例：</strong></p>
<p>12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85<br>10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60<br>10000008 75 79 10000001 64 90</p>
<hr>
<p><a href="https://www.patest.cn/contests/pat-b-practise/1015#" target="_blank" rel="noopener"> 提交代码 </a></p>
<p>思路分析：</p>
<p>本题的考点就是compare函数排序。<br>最重要的就是对数据对象进行排序，关键的核心也在于如何写排序条件，实际上在你掌握了compare方法的原理之后，再声明一个结构体数组这个题就迎刃而解了。</p>
<p>（我就是不太熟悉c++的开始用的java写的但就是有三个测试点不能a，在网上找到别人的java代码后也是那三个点不能a，（虽然在牛客网的系统上可以a），经过改造后的代码在c++里实现果然就通过了，但还是要注意在多次输出的时候，最好采用printf()的方式<br>，某些情况下会有超时的情况（这个题就是）！！！）。</p>
<p>思想很简单 ，看代码实现吧</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;


struct Student{

       int xue;
       int de;
       int cai;
       int zong;

};
bool compare(Student o1,Student o2){
    if(o1.zong != o2.zong){
                    return o1.zong &gt; o2.zong;
                }else if(o1.de != o2.de ){
                    return o1.de &gt; o2.de;
                }else{
                    return o2.xue &gt; o1.xue;
                } 

}
int main(){
    int N,L,H;
    scanf(&quot;%d%d%d&quot;,&amp;N,&amp;L,&amp;H);
    vector&lt;Student&gt; a1;
    vector&lt;Student&gt; a2;
    vector&lt;Student&gt; a3;
    vector&lt;Student&gt; a4;
    for(int i=0;i&lt;N;i++){
        int xue,de,cai;
        cin&gt;&gt;xue&gt;&gt;de&gt;&gt;cai;
        if(de&gt;=L &amp;&amp; cai&gt;=L){
            Student stu;
                stu.xue=xue;
                stu.de = de;
                stu.cai = cai;
                stu.zong = cai+de;

                if(de &gt;= H &amp;&amp; cai&gt;= H){
                    a1.push_back(stu);
                }else if(cai &lt;H &amp;&amp; de&gt;=H){
                    a2.push_back(stu);
                }else if(cai &lt;H &amp;&amp; de &lt;H &amp;&amp; de&gt;=cai ){
                    a3.push_back(stu);
                }else {
                    a4.push_back(stu);
                }

            }

    }
    sort(a1.begin(),a1.end(),compare);
    sort(a2.begin(),a2.end(),compare);
    sort(a3.begin(),a3.end(),compare);
    sort(a4.begin(),a4.end(),compare);
        cout&lt;&lt;a1.size()+a2.size()+a3.size()+a4.size()&lt;&lt;endl;
        for(int i=0;i&lt;a1.size();i++){
            printf(&quot;%d %d %d\n&quot;,a1[i].xue,a1[i].de,a1[i].cai);

        }for(int i=0;i&lt;a2.size();i++){
        printf(&quot;%d %d %d\n&quot;,a2[i].xue,a2[i].de,a2[i].cai);
        }
        for(int i=0;i&lt;a3.size();i++){
        printf(&quot;%d %d %d\n&quot;,a3[i].xue,a3[i].de,a3[i].cai);
        }
        for(int i=0;i&lt;a4.size();i++){
        printf(&quot;%d %d %d\n&quot;,a4[i].xue,a4[i].de,a4[i].cai);
        }
    return 0;
}</code></pre><p>java代码（19分）：<br>import java.io.BufferedInputStream;<br>import java.util.ArrayList;<br>import java.util.Collections;<br>import java.util.Comparator;<br>import java.util.Scanner;<br>class Student{<br>public int xue;<br>public int de;<br>public int cai;<br>public int zong;<br>public Student(int xue,int de, int cai, int zong) {<br>super();<br>this.xue = xue;<br>this.de = de;<br>this.cai = cai;<br>this.zong = zong;<br>}<br>public void toSTring(){<br>System.out.println(xue+” “+de +” “+cai );<br>}  </p>
<p>}<br>public class Main{<br>static Scanner scan = new Scanner(new BufferedInputStream(System.in));<br>public static void main(String[] args) {<br>ArrayList<Student> a1=new ArrayList<Student>();<br>ArrayList<Student> a2=new ArrayList<Student>();<br>ArrayList<Student> a3=new ArrayList<Student>();<br>ArrayList<Student> a4=new ArrayList<Student>();<br>int N = scan.nextInt();<br>int L =scan.nextInt();<br>int H =scan.nextInt();<br>Comparator<Student > c =new Comparator<Student>() {</p>
<p>@Override<br>public int compare(Student o1, Student o2){<br>if(o1.zong != o2.zong){<br>return o2.zong - o1.zong;<br>}else if(o1.de != o2.de ){<br>return o2.de - o1.de;<br>}else return o1.xue - o2.xue;<br>}<br>};<br>for(int i=0;i&lt;N;i++){<br>int xue,de,cai;<br>xue = scan .nextInt();<br>de = scan.nextInt();<br>cai = scan.nextInt();<br>if(de&gt;=L &amp;&amp; cai&gt;=L){<br>if(de &gt;= H &amp;&amp; cai&gt;= H){<br>a1.add(new Student(xue,de, cai, de+cai));<br>}else if(cai &lt;H &amp;&amp; de&gt;=H){<br>a2.add(new Student(xue,de, cai, de+cai));<br>}else if(cai &lt;H &amp;&amp; de &lt;H &amp;&amp; de&gt;=cai ){<br>a3.add(new Student(xue,de , cai , de+cai));<br>}else {<br>a4.add(new Student(xue,de , cai , de + cai));<br>}<br>}  </p>
<p>}  </p>
<p>Collections.sort(a1,c);<br>Collections.sort(a2,c);<br>Collections.sort(a3,c);<br>Collections.sort(a4,c);<br>System.out.println(a1.size()+a2.size()+a3.size()+a4.size());<br>for(int i=0;i&lt;a1.size();i++){<br>a1.get(i).toSTring();<br>}for(int i=0;i&lt;a2.size();i++){<br>a2.get(i).toSTring();<br>}<br>for(int i=0;i&lt;a3.size();i++){<br>a3.get(i).toSTring();<br>}<br>for(int i=0;i&lt;a4.size();i++){<br>a4.get(i).toSTring();<br>}  </p>
<p>}</p>
<p>}  </p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2017/12/06/pat%20%E4%B9%99%E7%BA%A7%201008.%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98%20(20)/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="pat 乙级 1008. 数组元素循环右移问题 (20)" class="lazyload">
                    <h1>pat 乙级 1008. 数组元素循环右移问题 (20)</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年12月06日</a>
            <a><i class="nexmoefont icon-areachart"></i>721 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
        </div>

        <article>
            
                <p>﻿﻿</p>
<h1 id="1008-数组元素循环右移问题-20"><a href="#1008-数组元素循环右移问题-20" class="headerlink" title="1008. 数组元素循环右移问题 (20)"></a>1008. 数组元素循环右移问题 (20)</h1><p>时间限制</p>
<p>400 ms  </p>
<p>内存限制</p>
<p>65536 kB  </p>
<p>代码长度限制</p>
<p>8000 B  </p>
<p>判题程序</p>
<p>Standard</p>
<p>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A  0  A  1  ……A<br>N-1  ）变换为（A  N-M  …… A  N-1  A  0  A  1  ……A  N-M-1<br>）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<p><strong>输入格式：</strong> 每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。</p>
<p><strong>输出格式：</strong> 在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>
<p><strong>输入样例：</strong></p>
<pre><code>6 2
1 2 3 4 5 6</code></pre><p><strong>输出样例：</strong></p>
<pre><code>5 6 1 2 3 4</code></pre><hr>
<p><a href="https://www.patest.cn/contests/pat-b-practise/1008#" target="_blank" rel="noopener"> 提交代码 </a></p>
<p>思路分析：这个题一开始的时候由于看到条件限制说只能使用一个数组去实现，我就被他限制住了思维，一直想着去用一个数组去实现判断位置的变化，但是没有做出来，在参考了大神的代码后，瞬间就想到了这不是让你去完成一个项目，它的要求只是为了输出一个序列，所以即使你一个数组都没有用，只要你能按照一定的算法去把这个序列输出就好了。那么这个题就变得很简单了。</p>
<p>用栈或者队列去解这道题就很简单，大致的思路就是判断前半部分的数据个数和后半部分数据的个数，分别压栈然后出栈就好了。</p>
<p>这里还有一个坑（其实稍微细想一下就能想到的，就是如果m&gt;n的话，数据移动的位置就不仅仅是m位那么简单了，他还需要取余运算去决定数据最后的位置。）</p>
<p>分为两种情况 1.m&lt;=n 2.m&gt;n</p>
<p>代码实现：</p>
<p>#include<iostream><br>#include<stack><br>using namespace std;<br>int main(){<br>int N,M;<br>scanf(“%d%d”,&amp;N,&amp;M);<br>int a[N];<br>stack<int> a1;<br>stack<int> b;<br>for(int i=0;i&lt;N;i++){<br>cin&gt;&gt;a[i];<br>}<br>if(M&lt;=N){<br>for(int i=N-M-1;i&gt;=0;i–){<br>a1.push(a[i]);<br>}<br>for(int j=N-1;j&gt;N-M-1;j–){<br>b.push(a[j]);<br>}<br>}else{<br>for(int i=N-1;i&gt;=N-(M%N);i–){<br>b.push(a[i]);<br>}<br>for(int j=N-(M%N)-1;j&gt;=0;j–){  </p>
<p>a1.push(a[j]);<br>}  </p>
<p>}<br>while(!b.empty()){<br>cout&lt;&lt;b.top()&lt;&lt;” “;<br>b.pop();<br>}<br>while(!a1.empty()){<br>if(a1.size()==1){<br>cout&lt;&lt;a1.top();<br>}else{<br>cout&lt;&lt;a1.top()&lt;&lt;” “;<br>}<br>a1.pop();<br>}<br>return 0;<br>}  </p>
<p><a href="http://39.106.25.239/" target="_blank" rel="noopener"> http://39.106.25.239/ </a> 个人做的项目 希望大家访问一下  </p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2017/11/27/PAT%20%E4%B9%99%E7%BA%A7%201007.%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3%20(20)%20c++%20%E7%AD%9B%E9%80%89%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="PAT 乙级 1007. 素数对猜想 (20) c++ 筛选法求素数" class="lazyload">
                    <h1>PAT 乙级 1007. 素数对猜想 (20) c++ 筛选法求素数</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年11月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>620 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <p>PAT 乙级 1007. 素数对猜想 (20) c++ 筛选法求素数</p>
<p>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn<br>是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。</p>
<p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p>
<p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p>
<p>输入样例：<br>20<br>输出样例：<br>4<br><strong>思路分析： 首先这道题如果用普通的求素数的方法写可能会超时，毕竟10的五次方了<br>然后还要去循环判断每一个数，我也是在网上看了别人的代码才知道有筛选法求素数的。筛选法求素数的基本思想就是把从1开始的、某一范围内的正整数从小到大顺序排列，<br>1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。依次类推，直到筛子为空时结束。。<br>最根本的思想可以说是不难，但实现起来。。其实实现起来也不难。</strong></p>
<p>代码实现：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
bool isprime [100001]; // bool数组标志1-100000的数据是否为素数
int count = 0,tmp =2;
void   getprime(int n){   //运用筛选法获得n以内的全部素数
    for(int i=2;i&lt;=n;i++){  //初始化为true即默认都是素数
        isprime[i]=true;
    }
    for(int j=2;j&lt;=n;j++){   //依次遍历后面的所有标志为true的数据
    if(isprime[j]==true){    //从第一个素数2开始判断 设置2的倍数（非素数）为false 因为素数的倍数肯定不是素数他至少有一个因子是该素数本身
        for(int m=2;j*m&lt;=n;++m){//  m为倍数 j为素数 去掉j的m倍即为去掉非素数
            isprime[j*m]=false;
        }
    }
}
for(int k=2;k&lt;=n;k++){
        if(isprime[k] == true){   //如果这个数据是素数 
            if(k - tmp == 2){  //如果这个数减去上一个相邻的素数结果为2 即素数对数加1
                count ++;
                tmp = k;    //更新tmp为本次的素数
            }
            else{
                tmp = k;
            }
        }
    }
cout&lt;&lt;count;
}
int main(){
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    getprime(N);
    return 0;
}</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/lingluan533.github.io/2017/11/23/PAT-B%201005.%20%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3%20(25)%20c++/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="PAT-B 1005. 继续(3n+1)猜想 (25) c++" class="lazyload">
                    <h1>PAT-B 1005. 继续(3n+1)猜想 (25) c++</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年11月23日</a>
            <a><i class="nexmoefont icon-areachart"></i>617 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <h1 id="1005-继续-3n-1-猜想-25"><a href="#1005-继续-3n-1-猜想-25" class="headerlink" title="1005. 继续(3n+1)猜想 (25)"></a>1005. 继续(3n+1)猜想 (25)</h1><p>时间限制</p>
<p>400 ms  </p>
<p>内存限制</p>
<p>65536 kB  </p>
<p>代码长度限制</p>
<p>8000 B  </p>
<p>判题程序</p>
<p>Standard</p>
<p>作者</p>
<p>CHEN, Yue  </p>
<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>
<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p>
<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>
<p><strong>输入格式：</strong><br>每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。</p>
<p><strong>输出格式：</strong> 每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p>
<p><strong>输入样例：</strong></p>
<pre><code>6
3 5 6 7 8 11</code></pre><p><strong>输出样例：</strong></p>
<p>7 6</p>
<p>思路分析：只要在对某个数进行猜想的时候  某个  数出现过则  这个数  就不是关键数了。只有这个数不被任何猜想过程包含的时候这个数才是关键数。</p>
<p>首先可以设置一个bool数组进行标识数的出现与否。</p>
<p>循环对输入的数进行猜想，如果过程中的n以前没有出现过（为false）则置flag(n)为true，以后在遇到这个数的时候则不对其进行修改了。</p>
<p>循环输入的测试数据的数组，如果没有出现过则加入到result数组。</p>
<p>用algorithm下的sort()函数进行从大到小的排序。</p>
<p>输出。</p>

            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
      <a class="extend prev" rel="prev" href="/lingluan533.github.io/"><i class="nexmoefont icon-left"></i></a><a class="page-number" href="/lingluan533.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/lingluan533.github.io/page/3/">3</a><a class="extend next" rel="next" href="/lingluan533.github.io/page/3/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js,gh/nexmoe/nexmoe.github.io@latest/js/app.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!--<script src="/lingluan533.github.io/js/app.js?v=1585654070933"></script>-->


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>



  





</body>

</html>
